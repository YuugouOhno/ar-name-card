<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite App</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.1.0/three.js/build/ar.js"></script>
  <!-- DRACOLoader.js -->
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/loaders/DRACOLoader.js"></script>

  <!-- GLTFLoader.js -->
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r110/examples/js/loaders/GLTFLoader.js"></script>
  <link rel="stylesheet" type="text/css" href="./style.css" />
</head>

<body>
  <a href="javascript:void(0)" onclick="fishview()">
    <span id="btn-value">魚を観察する</span>
  </a>

  <canvas id="canvas"></canvas>



  <script>
    let isFish = false;

    const fishview = () => {
      let text = document.getElementById('btn-value').innerHTML;
      if (isFish) {
        document.getElementById('btn-value').innerHTML = '<span id="btn-value">魚を観察する</span>';
        setNameCards();
        for (let i = 0; i < boids.length; i++) {
          // console.log(boids[i])
          scene.remove(boids[i].object);
        }
        boids.splice(0);
      } else {
        document.getElementById('btn-value').innerHTML = '<span id="btn-value">名刺を表示する</span>';
        createBoids(params);
        removeNameCards();
      }
      isFish = !isFish;
    }

    let w;
    let h;
    let canvas;
    let scene;
    let camera;
    let renderer;
    let object;
    let light;


    let arToolkitSource;
    let arToolkitContext;

    let pointer
    let raycaster
    let markerTime;

    const boids = [];
    const number_of_bois = [];

    const init = () => {
      w = window.innerWidth;
      h = window.innerHeight;
      canvas = document.getElementById("canvas");
      setScene();
      setCamera();
      setNameCards();
      // pointer = new THREE.Vector2();
      // raycaster = new THREE.Raycaster();
      // document.addEventListener('pointerdown', onPointerDown);
      // document.addEventListener( 'mousemove', onPointerMove );

      setLight();
      setArToolkit();
      setRenderer();
      animate();
    };

    const setScene = () => {
      scene = new THREE.Scene();
      scene.visible = false;
    };

    const setCamera = () => {
      camera = new THREE.PerspectiveCamera(100, w / h, 0.1, 1000);
      scene.add(camera);
    };

    const setLight = () => {
      light = new THREE.DirectionalLight("#ffffff", 4);
      scene.add(light);
    }

    const setArToolkit = () => {
      arToolkitSource = new THREEx.ArToolkitSource({
        sourceType: "webcam",
      });

      arToolkitSource.init(() => {
        setTimeout(() => {
          onResize();
        }, 2000);
      });

      arToolkitContext = new THREEx.ArToolkitContext({
        cameraParametersUrl:
          THREEx.ArToolkitContext.baseURL + "../data/data/camera_para.dat",
        detectionMode: "mono",
        // ※1 作ったマーカーのPattern Ratioを入れる
        patternRatio: 0.7,
      });

      arToolkitContext.init(
        (onCompleted = () => {
          camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        })
      );

      let onRenderFcts = [];
      onRenderFcts.push(() => {
        if (arToolkitSource.ready === false) return;
        arToolkitContext.update(arToolkitSource.domElement);
        scene.visible = camera.visible;
      });

      const markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
        type: "pattern",
        // ※2 マーカーのpattファイルのパスを入れる
        patternUrl: "./marker/pattern.patt",
        changeMatrixMode: "cameraTransformMatrix",
      });

      // markerTime = markerControls.addEventListener("markerFound", () => {
      //   // マーカーが見つかっている時は毎秒呼ばれる
      //   console.log("marker found");
      // });

    };

    const setObject = () => {
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshNormalMaterial();
      object = new THREE.Mesh(geometry, material);
      object.position.set(0, 0, 0);
      scene.add(object);
    };

    const setRenderer = () => {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        canvas: canvas,
      });
      renderer.setClearColor(0x000000, 0);
      renderer.setSize(w, h);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setAnimationLoop(() => {
        render();
      });
    };

    const render = () => {
      if (arToolkitSource.ready) {
        arToolkitContext.update(arToolkitSource.domElement);
        scene.visible = camera.visible;
      }
      renderer.render(scene, camera);
    };

    const onResize = () => {
      arToolkitSource.onResizeElement();
      arToolkitSource.copyElementSizeTo(renderer.domElement);
      if (arToolkitContext.arController !== null) {
        arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
      }
      camera.aspect = window.innerWidth / window.innerHeight;
      // camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    };

    const animate = () => {
      window.requestAnimationFrame(animate);

      // 名刺の動作


      // 魚の動作
      boids.forEach(biont => {
        biont.draw();
      });



      // Render
      renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
      onResize();
    });

    window.onload = () => {
      init();
      console.log("load")
    };

    // ----------------------------------------------------------------------------------------------------------------
    // 名刺の表示
    let icon
    let name
    let cardsContainer
    let twitter
    let github
    let qita
    let wantedly
    let click_objects = []

    const textureLoader = new THREE.TextureLoader();

    const setCardsContainer = () => {
      // 裏面のマテリアル
      const material_basesheet = new THREE.MeshPhongMaterial({
        transparent: true,
        opacity: 0.5,
        color: "#f5f5f5"
      });

      // アイコン
      const texture1 = textureLoader.load('./cardsContainer/icon.png');
      const geometry1 = new THREE.CylinderGeometry(1, 1, 0.1, 32)
      const material1 = new THREE.MeshBasicMaterial({
        map: texture1,
        side: THREE.DoubleSide,
      });
      const iconObject = new THREE.Mesh(geometry1, [material_basesheet, material1, material_basesheet]);
      iconObject.position.set(-1.1 * 0.7, 0, 0);
      iconObject.rotation.set(Math.PI * 1.85, Math.PI * 0.5, 0);

      // 名前
      const texture2 = textureLoader.load('./cardsContainer/name.png');
      const geometry2 = new THREE.BoxGeometry(3.5, 2, 0.1);
      const material2 = new THREE.MeshBasicMaterial({
        map: texture2,
        side: THREE.DoubleSide,
      });
      const nameObject = new THREE.Mesh(geometry2, [material_basesheet, material_basesheet, material_basesheet, material_basesheet, material2, material_basesheet]);
      nameObject.position.set(1.8 * 0.7, 0, 0);
      nameObject.rotation.x = -90;

      // 基本情報
      const texture3 = textureLoader.load('./cardsContainer/base-data.png');
      // const geometry3 = new THREE.PlaneGeometry(2.75, 2, 1, 1);
      const geometry3 = new THREE.BoxGeometry(2.75, 2, 0.1);
      const material3 = new THREE.MeshBasicMaterial({
        map: texture3,
        side: THREE.DoubleSide,
      });
      const dataObject = new THREE.Mesh(geometry3, [material_basesheet, material_basesheet, material_basesheet, material_basesheet, material3, material_basesheet]);
      dataObject.position.set(-0.7 * 0.7, 1 * 0.7, 1.9 * 0.7);
      dataObject.rotation.x = -90;

      // サイトのサムネ
      const texture4 = textureLoader.load('./cardsContainer/mysite-image.png');
      const geometry4 = new THREE.BoxGeometry(2.7, 2, 0.1);
      const material4 = new THREE.MeshBasicMaterial({
        map: texture4,
        side: THREE.DoubleSide,
      });
      const siteObject = new THREE.Mesh(geometry4, [material_basesheet, material_basesheet, material_basesheet, material_basesheet, material4, material_basesheet]);
      siteObject.position.set(2.15 * 0.7, 1 * 0.7, 1.9 * 0.7);
      siteObject.rotation.x = -90;

      // cardsContainer.scale.set(0.7, 0.7, 0.7);
      iconObject.scale.set(0.7, 0.7, 0.7);
      nameObject.scale.set(0.7, 0.7, 0.7);
      dataObject.scale.set(0.7, 0.7, 0.7);
      siteObject.scale.set(0.7, 0.7, 0.7);
      click_objects.push(iconObject)
      click_objects.push(nameObject)
      click_objects.push(dataObject)
      click_objects.push(siteObject)
      scene.add(iconObject, nameObject, dataObject, siteObject);
    }

    const setAcountsContainer = () => {
      // アカウントへのリンク
      //  twitter
      twitter = new THREE.Group();
      const geometry5 = new THREE.RingGeometry(0.5, 0.6, 6);
      const material5 = new THREE.MeshPhysicalMaterial({
        color: "#483d8b",
        metalness: 0.865,
        roughness: 0.373,
        side: THREE.DoubleSide
      });
      const card5 = new THREE.Mesh(geometry5, material5);
      card5.position.set(-1.3, 2, 3.6);
      card5.rotation.x = -90;
      twitter.add(card5)

      const texture5_2 = textureLoader.load('./accounts/twitter.png');
      const geometry5_2 = new THREE.CircleGeometry(0.4, 32)
      const material5_2 = new THREE.MeshBasicMaterial({
        map: texture5_2,
        side: THREE.DoubleSide,
      });
      const card5_2 = new THREE.Mesh(geometry5_2, material5_2);
      card5_2.position.set(-1.3, 2, 3.6);
      card5_2.rotation.x = -90;
      twitter.add(card5_2)

      // github
      github = new THREE.Group();
      const geometry6 = new THREE.RingGeometry(0.5, 0.6, 6);
      const material6 = new THREE.MeshPhysicalMaterial({
        color: "#483d8b",
        metalness: 0.865,
        roughness: 0.373,
        side: THREE.DoubleSide
      });
      const card6 = new THREE.Mesh(geometry6, material6);
      card6.position.set(0, 2, 3.6);
      card6.rotation.x = -90;
      github.add(card6)

      const texture6_2 = textureLoader.load('./accounts/github.png');
      const geometry6_2 = new THREE.CircleGeometry(0.4, 32)
      const material6_2 = new THREE.MeshBasicMaterial({
        map: texture6_2,
        side: THREE.DoubleSide,
      });
      const card6_2 = new THREE.Mesh(geometry6_2, material6_2);
      card6_2.position.set(0, 2, 3.6);
      card6_2.rotation.x = -90;
      github.add(card6_2)

      // qita
      qita = new THREE.Group();
      const geometry7 = new THREE.RingGeometry(0.5, 0.6, 6);
      const material7 = new THREE.MeshPhysicalMaterial({
        color: "#483d8b",
        metalness: 0.865,
        roughness: 0.373,
        side: THREE.DoubleSide
      });
      const card7 = new THREE.Mesh(geometry7, material7);
      card7.position.set(1.3, 2, 3.6);
      card7.rotation.x = -90;
      qita.add(card7)

      const texture7_2 = textureLoader.load('./accounts/qita.png');
      const geometry7_2 = new THREE.CircleGeometry(0.4, 32)
      const material7_2 = new THREE.MeshBasicMaterial({
        map: texture7_2,
        side: THREE.DoubleSide,
      });
      const card7_2 = new THREE.Mesh(geometry7_2, material7_2);
      card7_2.position.set(1.3, 2, 3.6);
      card7_2.rotation.x = -90;
      qita.add(card7_2)

      // wantedly
      wantedly = new THREE.Group();
      const geometry8 = new THREE.RingGeometry(0.5, 0.6, 6);
      const material8 = new THREE.MeshPhysicalMaterial({
        color: "#483d8b",
        metalness: 0.865,
        roughness: 0.373,
        side: THREE.Double
      });
      const card8 = new THREE.Mesh(geometry8, material8);
      card8.position.set(2.6, 2, 3.6);
      card8.rotation.x = -90;
      wantedly.add(card8)

      const texture8_2 = textureLoader.load('./accounts/wantedly.png');
      const geometry8_2 = new THREE.CircleGeometry(0.4, 32);
      const material8_2 = new THREE.MeshBasicMaterial({
        map: texture8_2,
        side: THREE.DoubleSide,
      });
      const card8_2 = new THREE.Mesh(geometry8_2, material8_2);
      card8_2.position.set(2.6, 2, 3.6);
      card8_2.rotation.x = -90;
      wantedly.add(card8_2)

      twitter.scale.set(0.7, 0.7, 0.7);
      github.scale.set(0.7, 0.7, 0.7);
      qita.scale.set(0.7, 0.7, 0.7);
      wantedly.scale.set(0.7, 0.7, 0.7);
      scene.add(twitter, github, qita, wantedly);
      // click_objects.push()
    }


    const setNameCards = () => {
      setCardsContainer()
      setAcountsContainer()
    }

    const removeNameCards = () => {
      scene.remove(cardsContainer);

    }

    // // マウスの移動
    // function onPointerMove(event) {

    //   pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    //   pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

    // }
    // // アカウントのアイコンにクリックイベントを付加
    // function onPointerDown(event) {
    //   pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
    //   raycaster.setFromCamera(pointer, camera);
    //   console.log(raycaster)

    //   let intersects = raycaster.intersectObjects(click_objects, true);

    //   console.log(click_objects)
    //   console.log(intersects)
    //   console.log(scene.children)

    //   if (intersects.length > 0) {

    //     const intersect = intersects[0];
    //     console.log("test")



    //     render();

    //   }

    // }


    // ----------------------------------------------------------------------------------------------------------------
    // 3dモデルの読み込み
    const createGlTFfish = () => {
      const glTFfish = new THREE.Group();
      const manager = new THREE.LoadingManager();
      manager.onProgress = function (item, loaded, total) { };
      const onProgress = function (xhr) { };
      const onError = function (xhr) { };

      // GLTF 3DモデルLoader
      const loader = new THREE.GLTFLoader();

      loader.setCrossOrigin('anonymous'); // r84 以降は明示的に setCrossOrigin() を指定する必要がある


      // Load a glTF Animation resource
      loader.load(
        // resource URL
        "./3dmodel/Shark.glb",
        // called when the resource is loaded
        function (gltf) {

          const mesh = gltf.scene;
          mesh.scale.set(6, 6, 6);
          mesh.rotation.set(0, -90, 0);
          glTFfish.add(mesh);

        }
      );
      return glTFfish;
    }



    // ----------------------------------------------------------------------------------------------------------------


    const fishMaterial = new THREE.MeshPhysicalMaterial({
      roughness: 0.8,
      transmission: 1,
      thickness: 1, // Add refraction!
    });

    const params = {
      TYPE: "purple",
      SPEED: 0.9,
      MAX_SPEED: 2,
      CENTER_OF_BOIDS: new THREE.Vector3(0, -100, 0), //群れの中心
      ACTION_RANGE_OF_BOIDS: 100, //群れの行動範囲
      WEIGHT_TO_SEPARATION: 2, //条件1 分離
      WEIGHT_TO_ALIGNMENT: 0.001, //条件2 整列
      WEIGHT_TO_COHESION: 0.001, //条件3 凝集
      SEPARATION_RANGE: 10, // 分離する範囲
      COHESION_RANGE: 30, // 凝集する範囲
      WEIGHT_TO_CENTER: 0.001,
      MATERIAL: fishMaterial,
      SCALE: { x: 0.7, y: 0.7, z: 0.7 },
      NUMBER: 100,
    }

    const createBoids = (params) => {
      console.log(markerTime)
      console.log("createfish")

      for (let i = 0; i < params.NUMBER; i++) {
        boids.push(
          new Biont((Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5), i, params)
        );
      }
    }

    const bodyGeometry = new THREE.OctahedronGeometry(5);
    const tailGeometry = new THREE.CircleGeometry(10, 32, 0, (Math.PI * 70) / 180);

    const fish = (scale, material) => {
      const body = new THREE.Mesh(bodyGeometry, material);
      body.position.set(0, 0, 0);
      body.scale.set(1, 1.1, 2);

      const tail1 = new THREE.Mesh(tailGeometry, material);
      tail1.position.set(0, 0, -5);
      tail1.rotation.set(-35 * (Math.PI) / 180, (Math.PI) / 2, 0);
      tail1.height = 0.1;

      const tail2 = new THREE.Mesh(tailGeometry, material);
      tail2.position.set(0, 0, -5);
      tail2.rotation.set(-35 * (Math.PI) / 180, -(Math.PI) / 2, 0);
      tail2.height = 0.1;

      const object = new THREE.Group();
      object.add(body);
      object.add(tail1);
      object.add(tail2);

      object.scale.set(scale.x, scale.y, scale.z);

      return object
    };

    class Biont {
      constructor(x, y, z, id, params) {
        // this.object = fish(params.SCALE, params.MATERIAL);
        this.object = createGlTFfish();
        scene.add(this.object)

        this.speed = params.SPEED; //速度
        this.max_speed = params.MAX_SPEED;
        this.weight_to_separation = params.WEIGHT_TO_SEPARATION; //条件1 分離
        this.weight_to_alignment = params.WEIGHT_TO_ALIGNMENT; //条件2 整列
        this.weight_to_cohesion = params.WEIGHT_TO_COHESION; //条件3 凝集
        this.separation_range = params.SEPARATION_RANGE; // 分離する範囲
        this.cohesion_range = params.COHESION_RANGE; // 凝集する範囲    
        this.weight_to_center = params.WEIGHT_TO_CENTER;

        this.center_of_boids = params.CENTER_OF_BOIDS; //群れの中心地点
        this.action_range_of_boids = params.ACTION_RANGE_OF_BOIDS //群れの行動範囲(半径)
        this.type = params.TYPE;
        this.id = id; // 個体識別番号

        this.xyz = new THREE.Vector3(x, y, z); //位置ベクトルの設定
        this.v = new THREE.Vector3(); //速度ベクトルの設定

        this.v_separation = new THREE.Vector3(); //分離のベクトル
        this.v_alignment = new THREE.Vector3(); //整列のベクトル
        this.v_cohesion = new THREE.Vector3(); //凝集のベクトル

        // 初期位置の反映
        this.object.position.copy(this.xyz);

        // 群れの種類の追加
        if (!number_of_bois.includes(this.type)) {
          number_of_bois.push(this.type);
        };
      }
      update() {
        //各条件の合算
        this.v.add(this.v_separation);
        this.v.add(this.v_alignment);
        this.v.add(this.v_cohesion);

        // 最高速度を設定
        if (this.v.length() > this.max_speed) {
          this.v.multiplyScalar(this.max_speed / this.v.length());
        } else if (this.v.length() < 0.1) {
          const random_move = Math.floor(Math.random() * 3) - 1
          this.v.addScalar(random_move)
        }


        //群れの速度の調整
        this.v.multiplyScalar(this.speed);

        //位置ベクトルに反映
        this.xyz.add(this.v);
      }
      draw() {
        //各条件の初期化
        this.v_separation.setScalar(0);
        this.v_alignment.setScalar(0);
        this.v_cohesion.setScalar(0);
        this.getSeparation(); // 分離
        this.getAlignment(); // 整列
        this.getCohesion(); // 集合
        this.setActionRange(); // 行動範囲外に出た際の処理
        this.update(); // 位置ベクトルに反映する
        this.setFaceDirection(); //進行方向を向く
        this.object.position.copy(this.xyz); // 描画
      }

      isInTheFieldOfVision(this_xyz, this_v, target_xyz) {
        return this_v.dot(target_xyz.sub(this_xyz)) > 0;
      }

      /**
       * 分離（Separation）
       */
      getSeparation() {
        const separation_vector = new THREE.Vector3();
        let separation_count = 0;
        boids.filter(biont =>
          biont.xyz.distanceTo(this.xyz) < this.separation_range &&
          this.type === biont.type
        ).forEach(biont => {
          const closeness = 1 / (Math.floor(biont.xyz.distanceTo(this.xyz)) + 1);
          separation_vector.add(this.xyz.clone().sub(biont.xyz).multiplyScalar(closeness));
          separation_count += 1;
        });
        if (separation_count) {
          separation_vector.divideScalar(separation_count);
        }
        this.v_separation.copy(separation_vector).multiplyScalar(this.weight_to_separation);

      }
      /**
       * 整列（Alignment）
       */
      getAlignment() {
        const alignment_vector = new THREE.Vector3();
        boids.filter(biont =>
          this.isInTheFieldOfVision(this.xyz.clone(), this.v.clone(), biont.xyz.clone()) &&
          this.type === biont.type
        ).forEach(biont => {
          alignment_vector.add(biont.xyz);
        });
        alignment_vector.divideScalar(boids.length - 1);
        alignment_vector.sub(this.v)
        this.v_alignment.copy(alignment_vector).multiplyScalar(this.weight_to_alignment);
      }
      /**
       * 凝集（Cohesion）
       */
      getCohesion() {
        const cohesion_vector = new THREE.Vector3();
        let cohesion_count = 0;
        boids.filter(biont =>
          this.isInTheFieldOfVision(this.xyz.clone(), this.v.clone(), biont.xyz.clone()) &&
          this.id !== biont.id &&
          this.type === biont.type &&
          biont.xyz.distanceTo(this.xyz) < this.cohesion_range
        ).forEach(biont => {
          const closeness = biont.xyz.distanceTo(this.xyz);
          cohesion_vector.add(biont.xyz.clone().sub(this.xyz).multiplyScalar(closeness));
          cohesion_count += 1;
        });
        if (cohesion_count) {
          cohesion_vector.divideScalar(cohesion_count);
        }
        this.v_cohesion.copy(cohesion_vector).multiplyScalar(this.weight_to_cohesion);
      }
      /**
       * 行動できる範囲
       */
      setActionRange() {
        if (this.center_of_boids.distanceTo(this.xyz) > this.action_range_of_boids) {
          const x = this.center_of_boids.distanceTo(this.xyz) - this.action_range_of_boids;
          this.v.sub(this.xyz.clone().multiplyScalar(x * this.weight_to_center));
        }
      }
      getRepellentForce() {

      }
      setFaceDirection() {
        this.object.lookAt(this.xyz);
      }
    }



  </script>
</body>

</html>